
import { Alert } from "@/types";

export interface VulnerabilityScore {
  baseScore: number;
  customScore: number;
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  factors: {
    exploitability: number;
    impact: number;
    recency: number;
    prevalence: number;
    zeroDay: boolean;
  };
}

export const calculateCustomCVEScore = (alert: Alert): VulnerabilityScore => {
  const now = new Date();
  const alertDate = new Date(alert.date);
  const daysSinceDiscovered = Math.floor((now.getTime() - alertDate.getTime()) / (1000 * 60 * 60 * 24));
  
  // Base CVSS score or default scoring
  let baseScore = 0;
  if (alert.details && typeof alert.details === 'object' && 'cvssScore' in alert.details) {
    baseScore = Number(alert.details.cvssScore) || 0;
  } else {
    // Default scoring based on severity
    switch (alert.severity) {
      case 'critical': baseScore = 9.5; break;
      case 'high': baseScore = 7.5; break;
      case 'medium': baseScore = 5.0; break;
      case 'low': baseScore = 2.5; break;
      default: baseScore = 5.0;
    }
  }
  
  // Calculate custom factors
  const factors = {
    exploitability: calculateExploitabilityScore(alert),
    impact: calculateImpactScore(alert),
    recency: calculateRecencyScore(daysSinceDiscovered),
    prevalence: calculatePrevalenceScore(alert),
    zeroDay: isZeroDay(alert, daysSinceDiscovered)
  };
  
  // Custom scoring algorithm
  let customScore = baseScore;
  
  // Boost for exploitability
  customScore *= (1 + factors.exploitability * 0.3);
  
  // Boost for high impact systems
  customScore *= (1 + factors.impact * 0.2);
  
  // Boost for recent vulnerabilities
  customScore *= (1 + factors.recency * 0.15);
  
  // Boost for prevalent vulnerabilities
  customScore *= (1 + factors.prevalence * 0.1);
  
  // Significant boost for zero-day
  if (factors.zeroDay) {
    customScore *= 1.5;
  }
  
  // Cap at 10
  customScore = Math.min(customScore, 10);
  
  // Determine risk level
  let riskLevel: 'low' | 'medium' | 'high' | 'critical';
  if (customScore >= 9 || factors.zeroDay) riskLevel = 'critical';
  else if (customScore >= 7) riskLevel = 'high';
  else if (customScore >= 4) riskLevel = 'medium';
  else riskLevel = 'low';
  
  return {
    baseScore,
    customScore: Math.round(customScore * 10) / 10,
    riskLevel,
    factors
  };
};

const calculateExploitabilityScore = (alert: Alert): number => {
  let score = 0;
  
  // Check for exploit keywords in description
  const exploitKeywords = ['exploit', 'poc', 'proof of concept', 'metasploit', 'remote code execution', 'rce'];
  const description = alert.description.toLowerCase();
  
  for (const keyword of exploitKeywords) {
    if (description.includes(keyword)) {
      score += 0.2;
    }
  }
  
  // Check system type for exploitability
  const systemType = alert.system.toLowerCase();
  if (systemType.includes('web') || systemType.includes('http')) score += 0.3;
  if (systemType.includes('ssh') || systemType.includes('remote')) score += 0.4;
  if (systemType.includes('database') || systemType.includes('sql')) score += 0.2;
  
  return Math.min(score, 1);
};

const calculateImpactScore = (alert: Alert): number => {
  let score = 0;
  
  // High impact systems
  const highImpactKeywords = ['authentication', 'admin', 'root', 'privileged', 'kernel', 'system'];
  const systemType = alert.system.toLowerCase();
  
  for (const keyword of highImpactKeywords) {
    if (systemType.includes(keyword)) {
      score += 0.3;
    }
  }
  
  // Impact based on description
  const impactKeywords = ['privilege escalation', 'data breach', 'unauthorized access', 'credential theft'];
  const description = alert.description.toLowerCase();
  
  for (const keyword of impactKeywords) {
    if (description.includes(keyword)) {
      score += 0.2;
    }
  }
  
  return Math.min(score, 1);
};

const calculateRecencyScore = (daysSinceDiscovered: number): number => {
  if (daysSinceDiscovered <= 1) return 1; // Same day
  if (daysSinceDiscovered <= 7) return 0.8; // Within a week
  if (daysSinceDiscovered <= 30) return 0.5; // Within a month
  if (daysSinceDiscovered <= 90) return 0.2; // Within 3 months
  return 0; // Older than 3 months
};

const calculatePrevalenceScore = (alert: Alert): number => {
  // This could be enhanced with actual prevalence data
  // For now, estimate based on system type and CVE
  let score = 0;
  
  const commonSystems = ['windows', 'linux', 'apache', 'nginx', 'php', 'java'];
  const systemType = alert.system.toLowerCase();
  
  for (const system of commonSystems) {
    if (systemType.includes(system)) {
      score += 0.2;
    }
  }
  
  return Math.min(score, 1);
};

const isZeroDay = (alert: Alert, daysSinceDiscovered: number): boolean => {
  // Zero-day indicators
  const zeroKeywords = ['zero-day', '0-day', 'no patch', 'unpatched', 'in-the-wild'];
  const description = alert.description.toLowerCase();
  
  for (const keyword of zeroKeywords) {
    if (description.includes(keyword)) {
      return true;
    }
  }
  
  // Very recent vulnerabilities with high severity might be zero-day
  return daysSinceDiscovered <= 1 && alert.severity === 'critical';
};

export const detectZeroDayVulnerabilities = (alerts: Alert[]): Alert[] => {
  return alerts.filter(alert => {
    const score = calculateCustomCVEScore(alert);
    return score.factors.zeroDay;
  });
};

export const prioritizeByCustomScore = (alerts: Alert[]): Alert[] => {
  return [...alerts].sort((a, b) => {
    const scoreA = calculateCustomCVEScore(a);
    const scoreB = calculateCustomCVEScore(b);
    
    // First priority: Zero-day vulnerabilities
    if (scoreA.factors.zeroDay && !scoreB.factors.zeroDay) return -1;
    if (!scoreA.factors.zeroDay && scoreB.factors.zeroDay) return 1;
    
    // Then by custom score
    return scoreB.customScore - scoreA.customScore;
  });
};
