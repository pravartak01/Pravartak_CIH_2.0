def extract_vulnerability_data(self):
        """Extract vulnerability data with real-time feedback"""
        self.colored_typewriter_effect("ğŸ§  Activating AI-powered data extraction algorithms...", Colors.PURPLE)
        
        try:
            # Wait for content to load with progress indicator
            print(f"{Colors.CYAN}â³ Waiting for dynamic content to load...{Colors.END}")
            for i in range(1, 4):
                self.progress_bar(i, 3, "ğŸ“¡ Content Loading")
                time.sleep(1)
            print()
            
            print(f"{Colors.GREEN}ğŸ”¬ Analyzing page content structure...{Colors.END}")
            
            # Look for vulnerability entries using various selectors
            selectors_to_try = [
                "//div[contains(@class, 'row') and contains(.//text(), 'CVE-')]",
                "//tr[contains(., 'CVE-')]",
                "//div[contains(text(), 'CVE-')]",
                "//a[contains(@href, 'CVE-')]",
                "//*[contains(text(), 'CVE-')]"
            ]
            
            found_elements = []
            
            for i, selector in enumerate(selectors_to_try):
                self.colored_typewriter_effect(f"ğŸ” Testing extraction pattern {i+1}/5...", Colors.YELLOW)
                try:
                    elements = self.driver.find_elements(By.XPATH, selector)
                    if elements:
                        found_elements.extend(elements[:10])  # Limit to prevent overwhelming
                        print(f"{Colors.GREEN}âœ… Pattern {i+1} successful! Found {len(elements)} potential targets{Colors.END}")
                        
                        # Dramatic highlighting of found elements
                        for j, elem in enumerate(elements[:3]):  # Highlight first 3
                            try:
                                self.driver.execute_script("""
                                    arguments[0].style.outline = '2px solid #00ff00';
                                    arguments[0].style.backgroundColor = 'rgba(0, 255, 0, 0.2)';
                                """, elem)
                                time.sleep(0.3)
                            except:
                                pass
                        break
                except:
                    print(f"{Colors.RED}âŒ Pattern {i+1} unsuccessful{Colors.END}")
                    continue
            
            if not found_elements:
                # Fallback: get all text content and parse
                print(f"{Colors.YELLOW}ğŸ”„ Engaging fallback extraction protocol...{Colors.END}")
                page_source = self.driver.page_source
                
                # Simple CVE pattern matching
                import re
                cve_pattern = r'CVE-\d{4}-\d{4,}'
                cves = re.findall(cve_pattern, page_source)
                
                if cves:
                    unique_cves = list(set(cves))[:10]
                    print(f"{Colors.CYAN}ğŸ¯ Extracted {len(unique_cves)} unique CVE identifiers{Colors.END}")
                    
                    for i, cve in enumerate(unique_cves):
                        self.progress_bar(i+1, len(unique_cves), "ğŸ“‹ Cataloguing CVEs")
                        
                        self.vulnerabilities.append({
                            'cve_id': cve,
                            'source': 'NVD',
                            'extracted_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                            'method': 'regex_extraction'
                        })
                        time.sleep(0.5)  # Dramatic pause
                    print()
                        
            else:
                total_elements = min(len(found_elements), 10)
                print(f"{Colors.PURPLE}ğŸ¯ Processing {total_elements} vulnerability records...{Colors.END}")
                
                for i, element in enumerate(found_elements[:10]):
                    try:
                        self.progress_bar(i+1, total_elements, "âš¡ Processing records")
                        
                        # Extract text content
                        text_content = element.text.strip()
                        
                        # Look for CVE pattern
                        import re
                        cve_match = re.search(r'CVE-\d{4}-\d{4,}', text_content)
                        
                        if cve_match:
                            cve_id = cve_match.group()
                            
                            # Try to extract additional details
                            description = text_content.replace(cve_id, '').strip()[:100]
                            
                            vulnerability = {
                                'cve_id': cve_id,
                                'description': description if description else 'Description not available',
                                'source': 'NVD',
                                'extracted_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                                'method': 'dom_extraction'
                            }
                            
                            self.vulnerabilities.append(vulnerability)
                            
                        time.sleep(random.uniform(0.3, 0.7))  # Human-like delay
                        
                    except Exception as e:
                        continue
                print()
            
            self.total_scraped = len(self.vulnerabilities)
            
            # Dramatic completion announcement
            print(f"\n{Colors.BG_GREEN}{Colors.WHITE}{Colors.BOLD}ğŸ† EXTRACTION COMPLETE! {self.total_scraped} VULNERABILITIES CATALOGUED ğŸ†{Colors.END}")
            
            # Flash effect
            for _ in range(3):
                print(f"{Colors.BLINK}{Colors.RED}âš¡ DATA SECURED âš¡{Colors.END}", end="")
                time.sleep(0.5)
                print(f"\r{' ' * 20}", end="")
                time.sleep(0.5)
            print()
            
            return True
            
        except Exception as e:
            print(f"{Colors.RED}âŒ Extraction protocol encountered an error: {str(e)}{Colors.END}")
            return False#!/usr/bin/env python3
"""
ğŸ” Automated Vulnerability Intelligence Scraper
==================================================
A sophisticated web scraping bot that demonstrates automated vulnerability data collection
with real-time visual feedback and intelligent parsing capabilities.

Author: Security Research Bot
Purpose: Educational demonstration of web scraping techniques
"""

import time
import random
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.common.keys import Keys
import pandas as pd
from datetime import datetime
import json
import sys
import os

# Terminal colors for dramatic effect
class Colors:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    END = '\033[0m'
    BLINK = '\033[5m'
    
    # Background colors
    BG_RED = '\033[41m'
    BG_GREEN = '\033[42m'
    BG_YELLOW = '\033[43m'
    BG_BLUE = '\033[44m'

class VulnerabilityScrapingBot:
    def __init__(self):
        self.vulnerabilities = []
        self.total_scraped = 0
        self.start_time = time.time()
        
    def clear_screen(self):
        """Clear terminal screen for dramatic effect"""
        os.system('cls' if os.name == 'nt' else 'clear')
        
    def print_banner(self):
        """Display an impressive banner for the scraping bot"""
        self.clear_screen()
        banner = f"""
{Colors.CYAN}{Colors.BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ¤– VULNERABILITY INTELLIGENCE BOT ğŸ¤–                      â•‘
â•‘                                                                              â•‘
â•‘  ğŸ” Automated Security Research Assistant                                    â•‘
â•‘  ğŸŒ Target: National Vulnerability Database (NVD)                           â•‘
â•‘  âš¡ Status: {Colors.BLINK}INITIALIZING ADVANCED SCRAPING PROTOCOLS{Colors.END}{Colors.CYAN}{Colors.BOLD}                        â•‘
â•‘                                                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{Colors.END}
"""
        print(banner)
        self.fancy_loading_animation()
        self.colored_typewriter_effect("ğŸš€ Initializing sophisticated web scraping algorithms...", Colors.GREEN)
        
    def fancy_loading_animation(self):
        """Create a fancy loading animation"""
        animation_chars = "â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â "
        colors = [Colors.RED, Colors.YELLOW, Colors.GREEN, Colors.CYAN, Colors.BLUE, Colors.PURPLE]
        
        for _ in range(20):
            for i, char in enumerate(animation_chars):
                color = colors[i % len(colors)]
                sys.stdout.write(f'\r{color}[{char}] Calibrating neural networks...{Colors.END}')
                sys.stdout.flush()
                time.sleep(0.1)
        print(f"\r{Colors.GREEN}âœ… Neural networks calibrated successfully!{Colors.END}")
        
    def colored_typewriter_effect(self, text, color=Colors.WHITE, delay=0.03):
        """Creates a colored typewriter effect for dramatic output"""
        for char in text:
            sys.stdout.write(f"{color}{char}{Colors.END}")
            sys.stdout.flush()
            time.sleep(delay)
        print()
        
    def progress_bar(self, current, total, description="Progress"):
        """Display a colorful progress bar"""
        bar_length = 40
        filled_length = int(bar_length * current // total)
        bar = f"{Colors.GREEN}{'â–ˆ' * filled_length}{Colors.RED}{'â–‘' * (bar_length - filled_length)}{Colors.END}"
        percent = f"{Colors.YELLOW}{100 * (current / float(total)):.1f}%{Colors.END}"
        sys.stdout.write(f'\r{Colors.CYAN}{description}:{Colors.END} |{bar}| {percent}')
        sys.stdout.flush()
        
    def dramatic_pause(self, message, duration=2):
        """Create dramatic pause with countdown"""
        print(f"{Colors.YELLOW}â³ {message}{Colors.END}")
        for i in range(duration, 0, -1):
            sys.stdout.write(f'\r{Colors.BLINK}{Colors.RED}âš¡ Executing in {i}...{Colors.END}')
            sys.stdout.flush()
            time.sleep(1)
        print(f"\r{Colors.GREEN}ğŸš€ EXECUTING NOW!{Colors.END}")
        
    def browser_dramatic_actions(self):
        """Perform dramatic browser interactions"""
        try:
            print(f"\n{Colors.PURPLE}{Colors.BOLD}ğŸ¬ INITIATING DRAMATIC BROWSER SEQUENCE{Colors.END}")
            
            # Smooth scrolling animation
            self.colored_typewriter_effect("ğŸ“œ Performing intelligent page reconnaissance...", Colors.CYAN)
            
            # Get page height for progressive scrolling
            page_height = self.driver.execute_script("return document.body.scrollHeight")
            viewport_height = self.driver.execute_script("return window.innerHeight")
            
            scroll_steps = 8
            step_size = page_height // scroll_steps
            
            for i in range(scroll_steps):
                self.progress_bar(i+1, scroll_steps, "ğŸ” Scanning page sections")
                
                # Smooth scroll to position
                target_position = (i + 1) * step_size
                self.driver.execute_script(f"""
                    window.scrollTo({{
                        top: {target_position},
                        behavior: 'smooth'
                    }});
                """)
                
                # Highlight current viewport with JavaScript
                self.driver.execute_script("""
                    // Create scanning overlay effect
                    var overlay = document.createElement('div');
                    overlay.id = 'scanner-overlay';
                    overlay.style.position = 'fixed';
                    overlay.style.top = '0';
                    overlay.style.left = '0';
                    overlay.style.width = '100%';
                    overlay.style.height = '100%';
                    overlay.style.background = 'linear-gradient(45deg, rgba(0,255,0,0.1), rgba(0,255,255,0.1))';
                    overlay.style.border = '3px solid #00ff00';
                    overlay.style.boxSizing = 'border-box';
                    overlay.style.zIndex = '9999';
                    overlay.style.pointerEvents = 'none';
                    overlay.style.animation = 'scanner-pulse 1s ease-in-out';
                    
                    // Add CSS animation
                    var style = document.createElement('style');
                    style.textContent = '@keyframes scanner-pulse { 0% { opacity: 0; } 50% { opacity: 1; } 100% { opacity: 0; } }';
                    document.head.appendChild(style);
                    document.body.appendChild(overlay);
                    
                    // Remove overlay after animation
                    setTimeout(() => {
                        if(document.getElementById('scanner-overlay')) {
                            document.getElementById('scanner-overlay').remove();
                        }
                    }, 1000);
                """)
                
                time.sleep(1.5)
            
            print(f"\n{Colors.GREEN}âœ… Page reconnaissance complete!{Colors.END}")
            
            # Dramatic element highlighting
            self.colored_typewriter_effect("ğŸ¯ Activating target acquisition systems...", Colors.YELLOW)
            
            # Find and dramatically highlight elements
            elements = self.driver.find_elements(By.XPATH, "//*[contains(text(), 'CVE-') or contains(text(), 'vulnerability') or contains(text(), 'security')]")
            
            if elements:
                highlighted_count = 0
                for element in elements[:5]:  # Highlight first 5 elements
                    try:
                        # Scroll element into view with dramatic effect
                        self.driver.execute_script("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});", element)
                        time.sleep(0.5)
                        
                        # Highlight element with pulsing border
                        self.driver.execute_script("""
                            arguments[0].style.border = '3px solid #ff0000';
                            arguments[0].style.backgroundColor = 'rgba(255, 255, 0, 0.3)';
                            arguments[0].style.transition = 'all 0.5s ease';
                            arguments[0].style.boxShadow = '0 0 20px rgba(255, 0, 0, 0.7)';
                        """, element)
                        
                        highlighted_count += 1
                        print(f"{Colors.RED}ğŸ¯ Target {highlighted_count} acquired and locked!{Colors.END}")
                        time.sleep(0.8)
                        
                        # Remove highlight
                        self.driver.execute_script("""
                            arguments[0].style.border = '';
                            arguments[0].style.backgroundColor = '';
                            arguments[0].style.boxShadow = '';
                        """, element)
                        
                    except Exception:
                        continue
                        
                print(f"{Colors.GREEN}ğŸ† Successfully highlighted {highlighted_count} potential targets!{Colors.END}")
            
            # Mouse movement simulation
            self.colored_typewriter_effect("ğŸ–±ï¸  Simulating human-like cursor movements...", Colors.PURPLE)
            
            actions = ActionChains(self.driver)
            
            # Create random mouse movements
            for i in range(5):
                x_offset = random.randint(-100, 100)
                y_offset = random.randint(-50, 50)
                actions.move_by_offset(x_offset, y_offset)
                actions.pause(random.uniform(0.5, 1.0))
                
            actions.perform()
            print(f"{Colors.GREEN}âœ… Human behavior simulation complete!{Colors.END}")
            
            # Final dramatic scroll to top
            self.colored_typewriter_effect("ğŸ”„ Returning to strategic overview position...", Colors.CYAN)
            self.driver.execute_script("window.scrollTo({top: 0, behavior: 'smooth'});")
            time.sleep(2)
            
        except Exception as e:
            print(f"{Colors.RED}âš ï¸  Dramatic sequence adapted due to page constraints{Colors.END}")
            
    def typewriter_effect(self, text, delay=0.03):
        """Legacy method - now redirects to colored version"""
        self.colored_typewriter_effect(text, Colors.WHITE, delay)
        
    def setup_driver(self):
        """Configure Chrome driver with stealth options"""
        self.colored_typewriter_effect("ğŸ”§ Configuring stealth browser parameters...", Colors.CYAN)
        
        chrome_options = Options()
        chrome_options.add_argument("--disable-blink-features=AutomationControlled")
        chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
        chrome_options.add_experimental_option('useAutomationExtension', False)
        chrome_options.add_argument("--disable-extensions")
        chrome_options.add_argument("--no-sandbox")
        chrome_options.add_argument("--disable-dev-shim-usage")
        chrome_options.add_argument("--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
        chrome_options.add_argument("--window-size=1920,1080")
        
        # Uncomment the next line to run headlessly (without GUI)
        # chrome_options.add_argument("--headless")
        
        try:
            print(f"{Colors.YELLOW}âš¡ Initializing quantum browser matrix...{Colors.END}")
            self.driver = webdriver.Chrome(options=chrome_options)
            
            # Make browser fullscreen for dramatic effect
            self.driver.maximize_window()
            
            self.driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
            print(f"{Colors.GREEN}âœ… Browser initialized successfully!{Colors.END}")
            print(f"{Colors.PURPLE}ğŸŒ Advanced anti-detection measures activated!{Colors.END}")
            
            # Add some dramatic browser effects
            self.driver.execute_script("""
                document.title = 'ğŸ¤– VULNERABILITY SCANNER ACTIVE ğŸ¤–';
                console.log('%cğŸš€ AUTOMATED SECURITY BOT ACTIVATED', 'color: #ff0000; font-size: 20px; font-weight: bold;');
            """)
            
            return True
        except Exception as e:
            print(f"{Colors.RED}âŒ Failed to initialize browser: {str(e)}{Colors.END}")
            print(f"{Colors.YELLOW}ğŸ’¡ Make sure ChromeDriver is installed and in PATH{Colors.END}")
            return False
            
    def navigate_to_nvd(self):
        """Navigate to NVD vulnerability search page"""
        self.colored_typewriter_effect("ğŸ¯ Targeting National Vulnerability Database...", Colors.RED)
        
        try:
            url = "https://nvd.nist.gov/vuln/search"
            
            self.dramatic_pause("Establishing encrypted connection", 3)
            
            self.driver.get(url)
            
            print(f"{Colors.CYAN}ğŸ“¡ Establishing connection to: {Colors.UNDERLINE}{url}{Colors.END}")
            
            # Show connection progress
            for i in range(1, 6):
                self.progress_bar(i, 5, "ğŸ”— Connection Status")
                time.sleep(0.5)
            print()
            
            # Wait for page to load
            WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.TAG_NAME, "body"))
            )
            
            print(f"{Colors.GREEN}ğŸ”— Connection established successfully!{Colors.END}")
            print(f"{Colors.PURPLE}ğŸ“Š Analyzing page structure...{Colors.END}")
            
            # Perform dramatic browser actions
            self.browser_dramatic_actions()
            
            return True
            
        except Exception as e:
            print(f"{Colors.RED}âŒ Navigation failed: {str(e)}{Colors.END}")
            return False
            
    def perform_search(self, keyword="critical"):
        """Perform vulnerability search with dramatic effects"""
        self.colored_typewriter_effect(f"ğŸ” Initiating deep scan for '{keyword}' vulnerabilities...", Colors.YELLOW)
        
        try:
            # Find and interact with search elements
            search_elements = self.driver.find_elements(By.XPATH, "//input[@type='text' or @type='search']")
            
            if search_elements:
                search_box = search_elements[0]
                
                # Highlight the search box dramatically
                self.driver.execute_script("""
                    arguments[0].style.border = '3px solid #00ff00';
                    arguments[0].style.boxShadow = '0 0 15px rgba(0, 255, 0, 0.8)';
                    arguments[0].style.backgroundColor = 'rgba(0, 255, 0, 0.1)';
                """, search_box)
                
                print(f"{Colors.GREEN}âŒ¨ï¸  Injecting search parameters...{Colors.END}")
                
                # Clear any existing text with dramatic effect
                search_box.clear()
                time.sleep(0.5)
                
                # Simulate human-like typing with visual feedback
                for i, char in enumerate(keyword):
                    search_box.send_keys(char)
                    self.progress_bar(i+1, len(keyword), f"ğŸ”¤ Typing '{keyword}'")
                    time.sleep(random.uniform(0.2, 0.4))
                print()
                
                print(f"{Colors.CYAN}ğŸ¯ Search query '{keyword}' successfully injected!{Colors.END}")
                
                # Remove highlight
                self.driver.execute_script("""
                    arguments[0].style.border = '';
                    arguments[0].style.boxShadow = '';
                    arguments[0].style.backgroundColor = '';
                """, search_box)
                
                # Look for search button with dramatic highlighting
                search_buttons = self.driver.find_elements(By.XPATH, "//button[contains(text(), 'Search') or @type='submit']")
                if search_buttons:
                    button = search_buttons[0]
                    
                    # Highlight button
                    self.driver.execute_script("""
                        arguments[0].style.backgroundColor = '#ff0000';
                        arguments[0].style.color = 'white';
                        arguments[0].style.transform = 'scale(1.1)';
                        arguments[0].style.transition = 'all 0.3s ease';
                    """, button)
                    
                    self.dramatic_pause("Executing search command", 2)
                    button.click()
                    
                    # Reset button style
                    self.driver.execute_script("""
                        arguments[0].style.backgroundColor = '';
                        arguments[0].style.color = '';
                        arguments[0].style.transform = '';
                    """, button)
                    
                    time.sleep(3)
                else:
                    # Try pressing Enter with dramatic effect
                    print(f"{Colors.YELLOW}ğŸ”„ Activating alternative execution method...{Colors.END}")
                    search_box.send_keys(Keys.RETURN)
                    time.sleep(3)
                
                print(f"{Colors.GREEN}âœ… Search executed successfully!{Colors.END}")
                return True
            else:
                print(f"{Colors.YELLOW}âš ï¸  Search interface not detected, proceeding with direct scraping...{Colors.END}")
                return True
                
        except Exception as e:
            print(f"{Colors.YELLOW}âš ï¸  Search adaptation required: {str(e)}{Colors.END}")
            print(f"{Colors.CYAN}ğŸ”„ Switching to alternative scraping method...{Colors.END}")
            return True
            
    def extract_vulnerability_data(self):
        """Extract vulnerability data with real-time feedback"""
        self.typewriter_effect("ğŸ§  Activating AI-powered data extraction algorithms...")
        
        try:
            # Wait for content to load
            time.sleep(3)
            
            print("ğŸ”¬ Analyzing page content structure...")
            
            # Look for vulnerability entries using various selectors
            selectors_to_try = [
                "//div[contains(@class, 'row') and contains(.//text(), 'CVE-')]",
                "//tr[contains(., 'CVE-')]",
                "//div[contains(text(), 'CVE-')]",
                "//a[contains(@href, 'CVE-')]",
                "//*[contains(text(), 'CVE-')]"
            ]
            
            found_elements = []
            
            for i, selector in enumerate(selectors_to_try):
                print(f"ğŸ” Testing extraction pattern {i+1}/5...")
                try:
                    elements = self.driver.find_elements(By.XPATH, selector)
                    if elements:
                        found_elements.extend(elements[:10])  # Limit to prevent overwhelming
                        print(f"âœ… Pattern {i+1} successful! Found {len(elements)} potential targets")
                        break
                except:
                    continue
            
            if not found_elements:
                # Fallback: get all text content and parse
                print("ğŸ”„ Engaging fallback extraction protocol...")
                page_source = self.driver.page_source
                
                # Simple CVE pattern matching
                import re
                cve_pattern = r'CVE-\d{4}-\d{4,}'
                cves = re.findall(cve_pattern, page_source)
                
                if cves:
                    print(f"ğŸ¯ Extracted {len(set(cves))} unique CVE identifiers")
                    for cve in list(set(cves))[:10]:  # Show first 10 unique CVEs
                        self.vulnerabilities.append({
                            'cve_id': cve,
                            'source': 'NVD',
                            'extracted_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                            'method': 'regex_extraction'
                        })
                        print(f"ğŸ“‹ Catalogued: {cve}")
                        time.sleep(0.5)  # Dramatic pause
                        
            else:
                print(f"ğŸ¯ Processing {len(found_elements)} vulnerability records...")
                
                for i, element in enumerate(found_elements[:10]):
                    try:
                        print(f"âš¡ Processing record {i+1}/{min(len(found_elements), 10)}...")
                        
                        # Extract text content
                        text_content = element.text.strip()
                        
                        # Look for CVE pattern
                        import re
                        cve_match = re.search(r'CVE-\d{4}-\d{4,}', text_content)
                        
                        if cve_match:
                            cve_id = cve_match.group()
                            
                            # Try to extract additional details
                            description = text_content.replace(cve_id, '').strip()[:100]
                            
                            vulnerability = {
                                'cve_id': cve_id,
                                'description': description if description else 'Description not available',
                                'source': 'NVD',
                                'extracted_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                                'method': 'dom_extraction'
                            }
                            
                            self.vulnerabilities.append(vulnerability)
                            print(f"âœ… {cve_id} successfully catalogued!")
                            
                        time.sleep(random.uniform(0.3, 0.7))  # Human-like delay
                        
                    except Exception as e:
                        print(f"âš ï¸  Record {i+1} processing incomplete: partial data recovered")
                        continue
            
            self.total_scraped = len(self.vulnerabilities)
            print(f"\nğŸ† Extraction complete! {self.total_scraped} vulnerabilities catalogued")
            return True
            
        except Exception as e:
            print(f"âŒ Extraction protocol encountered an error: {str(e)}")
            return False
            
    def display_results(self):
        """Display extracted data in an impressive format"""
        print(f"\n{Colors.CYAN}{'='*80}{Colors.END}")
        print(f"{Colors.BOLD}{Colors.YELLOW}ğŸ“Š VULNERABILITY INTELLIGENCE REPORT{Colors.END}")
        print(f"{Colors.CYAN}{'='*80}{Colors.END}")
        
        if not self.vulnerabilities:
            print(f"{Colors.YELLOW}â„¹ï¸  No vulnerabilities extracted. This might be due to:{Colors.END}")
            print(f"{Colors.WHITE}   â€¢ Website structure changes{Colors.END}")
            print(f"{Colors.WHITE}   â€¢ Rate limiting or anti-bot measures{Colors.END}")
            print(f"{Colors.WHITE}   â€¢ Network connectivity issues{Colors.END}")
            print(f"\n{Colors.GREEN}ğŸ’¡ The bot successfully demonstrated:{Colors.END}")
            print(f"{Colors.GREEN}   âœ… Advanced browser automation{Colors.END}")
            print(f"{Colors.GREEN}   âœ… Intelligent element detection{Colors.END}")
            print(f"{Colors.GREEN}   âœ… Multiple extraction strategies{Colors.END}")
            print(f"{Colors.GREEN}   âœ… Error handling and fallback mechanisms{Colors.END}")
            print(f"{Colors.GREEN}   âœ… Dramatic visual browser interactions{Colors.END}")
            print(f"{Colors.GREEN}   âœ… Human-like behavioral simulation{Colors.END}")
            return
            
        for i, vuln in enumerate(self.vulnerabilities, 1):
            # Alternate colors for each vulnerability
            color = Colors.CYAN if i % 2 == 0 else Colors.PURPLE
            
            print(f"\n{color}ğŸ”¸ Vulnerability #{i}{Colors.END}")
            print(f"{Colors.WHITE}   CVE ID: {Colors.BOLD}{Colors.RED}{vuln['cve_id']}{Colors.END}")
            print(f"{Colors.WHITE}   Description: {vuln.get('description', 'N/A')}{Colors.END}")
            print(f"{Colors.WHITE}   Source: {Colors.GREEN}{vuln['source']}{Colors.END}")
            print(f"{Colors.WHITE}   Extracted: {Colors.YELLOW}{vuln['extracted_at']}{Colors.END}")
            print(f"{Colors.WHITE}   Method: {Colors.BLUE}{vuln['method']}{Colors.END}")
            
        print(f"\n{Colors.BG_BLUE}{Colors.WHITE}{Colors.BOLD}ğŸ“ˆ STATISTICS:{Colors.END}")
        print(f"{Colors.CYAN}   Total Vulnerabilities: {Colors.BOLD}{Colors.GREEN}{self.total_scraped}{Colors.END}")
        print(f"{Colors.CYAN}   Execution Time: {Colors.BOLD}{Colors.YELLOW}{time.time() - self.start_time:.2f} seconds{Colors.END}")
        print(f"{Colors.CYAN}   Average Time per Record: {Colors.BOLD}{Colors.PURPLE}{(time.time() - self.start_time)/max(self.total_scraped, 1):.2f} seconds{Colors.END}")
        
        # ASCII art celebration
        if self.total_scraped > 0:
            celebration = f"""
{Colors.GREEN}
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— 
    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â• 
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—
    â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
    â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•
    â•šâ•â•     â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•šâ•â•  â•šâ•â•â•â• â•šâ•â•â•â•â•â• 
{Colors.END}"""
            print(celebration)
        
    def save_data(self):
        """Save extracted data to files"""
        if not self.vulnerabilities:
            return
            
        print(f"\n{Colors.PURPLE}ğŸ’¾ Initiating data persistence protocols...{Colors.END}")
        
        # Dramatic saving animation
        save_steps = ["Encrypting data", "Compressing payload", "Securing transmission", "Writing to disk"]
        for i, step in enumerate(save_steps):
            self.progress_bar(i+1, len(save_steps), f"ğŸ’¾ {step}")
            time.sleep(0.8)
        print()
        
        # Save as JSON
        filename_json = f"vulnerability_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(filename_json, 'w') as f:
            json.dump(self.vulnerabilities, f, indent=2)
        print(f"{Colors.GREEN}âœ… JSON report saved: {Colors.UNDERLINE}{filename_json}{Colors.END}")
        
        # Save as CSV
        try:
            df = pd.DataFrame(self.vulnerabilities)
            filename_csv = f"vulnerability_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
            df.to_csv(filename_csv, index=False)
            print(f"{Colors.GREEN}âœ… CSV report saved: {Colors.UNDERLINE}{filename_csv}{Colors.END}")
        except Exception as e:
            print(f"{Colors.YELLOW}âš ï¸  CSV export encountered issue: {str(e)}{Colors.END}")
            
        # Security confirmation
        print(f"{Colors.BG_GREEN}{Colors.WHITE}ğŸ”’ DATA SUCCESSFULLY SECURED AND ARCHIVED ğŸ”’{Colors.END}")
    
    def cleanup(self):
        """Clean up resources"""
        if hasattr(self, 'driver'):
            print(f"\n{Colors.YELLOW}ğŸ§¹ Cleaning up browser resources...{Colors.END}")
            
            # Dramatic cleanup sequence
            cleanup_steps = ["Clearing cache", "Removing traces", "Closing connections", "Terminating session"]
            for i, step in enumerate(cleanup_steps):
                self.progress_bar(i+1, len(cleanup_steps), f"ğŸ§¹ {step}")
                time.sleep(0.5)
            print()
            
            self.driver.quit()
            print(f"{Colors.GREEN}âœ… Browser session terminated successfully!{Colors.END}")
            
    def final_dramatic_sequence(self):
        """Final dramatic sequence before termination"""
        print(f"\n{Colors.PURPLE}{Colors.BOLD}ğŸ¬ INITIATING SHUTDOWN SEQUENCE{Colors.END}")
        
        # Matrix-style countdown
        countdown_messages = [
            "Disconnecting from neural network...",
            "Purging temporary algorithms...",
            "Securing extracted intelligence...",
            "Terminating all processes...",
            "MISSION ACCOMPLISHED!"
        ]
        
        for i, message in enumerate(countdown_messages):
            if i == len(countdown_messages) - 1:
                print(f"{Colors.BG_GREEN}{Colors.WHITE}{Colors.BOLD}ğŸ† {message} ğŸ†{Colors.END}")
            else:
                self.colored_typewriter_effect(f"âš¡ {message}", Colors.CYAN)
                time.sleep(1)
        
        # Final ASCII art
        final_art = f"""
{Colors.RED}
   â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—
   â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘
   â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘
   â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘
   â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
   â•šâ•â•     â•šâ•â•â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•â•
                                                        
        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
       â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•
       â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  
       â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â•  
       â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
        â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•     â•šâ•â•â•šâ•â•     â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•
{Colors.END}"""
        print(final_art)
            
    def run_full_scan(self):
        """Execute the complete vulnerability scanning process"""
        try:
            self.print_banner()
            
            if not self.setup_driver():
                return False
                
            if not self.navigate_to_nvd():
                return False
                
            # Perform search for different types of vulnerabilities
            search_terms = ["critical", "remote code execution", "buffer overflow", "SQL injection", "cross-site scripting"]
            selected_term = random.choice(search_terms)
            
            print(f"\n{Colors.PURPLE}ğŸ¯ Selected attack vector: {Colors.BOLD}{Colors.RED}{selected_term.upper()}{Colors.END}")
            
            self.perform_search(selected_term)
            self.extract_vulnerability_data()
            
            self.display_results()
            self.save_data()
            
            self.final_dramatic_sequence()
            
            print(f"\n{Colors.GREEN}ğŸ‰ Mission accomplished! All systems performed optimally.{Colors.END}")
            print(f"{Colors.CYAN}ğŸ”’ Security intelligence gathering complete.{Colors.END}")
            
            input(f"\n{Colors.BLINK}{Colors.YELLOW}ğŸ‘ï¸  Press Enter to terminate the session...{Colors.END}")
            
            return True
            
        except KeyboardInterrupt:
            print(f"\n\n{Colors.RED}âš ï¸  Operation interrupted by user{Colors.END}")
            print(f"{Colors.YELLOW}ğŸ›¡ï¸  Emergency shutdown protocol activated...{Colors.END}")
            
        except Exception as e:
            print(f"\n{Colors.RED}âŒ Critical error encountered: {str(e)}{Colors.END}")
            print(f"{Colors.YELLOW}ğŸ”§ Please check system requirements and network connectivity{Colors.END}")
            
        finally:
            self.cleanup()

def main():
    """Main execution function"""
    # Set terminal title for extra drama
    if os.name == 'nt':  # Windows
        os.system('title ğŸ¤– VULNERABILITY INTELLIGENCE BOT - ACTIVE SCAN')
    else:  # Unix/Linux/MacOS
        print('\033]2;ğŸ¤– VULNERABILITY INTELLIGENCE BOT - ACTIVE SCAN\007')
    
    print(f"{Colors.BOLD}{Colors.GREEN}ğŸš€ Starting Vulnerability Intelligence Bot...{Colors.END}")
    
    bot = VulnerabilityScrapingBot()
    bot.run_full_scan()

if __name__ == "__main__":
    main()